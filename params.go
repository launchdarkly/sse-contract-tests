package main

import (
	"errors"
	"flag"
	"fmt"
	"net/url"
	"strings"

	"github.com/launchdarkly/sse-contract-tests/framework"

	"github.com/alessio/shellescape"
)

type commandParams struct {
	serviceURL                string
	port                      int
	host                      string
	filters                   framework.RegexFilters
	debug                     bool
	debugAll                  bool
	outputDockerScriptVersion string
}

func (c *commandParams) Read(args []string) error {
	fs := flag.NewFlagSet("", flag.ExitOnError)
	fs.StringVar(&c.serviceURL, "url", "", "test service URL")
	fs.StringVar(&c.host, "host", "localhost", "external hostname of the test harness")
	fs.IntVar(&c.port, "port", defaultPort, "port that the test harness will listen on")
	fs.Var(&c.filters.MustMatch, "run", "regex pattern(s) to select tests to run")
	fs.Var(&c.filters.MustNotMatch, "skip", "regex pattern(s) to select tests not to run")
	fs.BoolVar(&c.debug, "debug", false, "enable debug logging for failed tests")
	fs.BoolVar(&c.debugAll, "debug-all", false, "enable debug logging for all tests")
	fs.StringVar(&c.outputDockerScriptVersion, "output-docker-script", "", "output a script for running the test in Docker (see README)")

	if err := fs.Parse(args[1:]); err != nil {
		return err
	}
	if c.serviceURL == "" {
		return errors.New("--url is required")
	}
	return nil
}

func (c commandParams) outputDockerScript() {
	targetURL, _ := url.Parse(c.serviceURL)
	testServiceHostname := targetURL.Hostname()
	testServicePort := targetURL.Port()

	var dockerArgs commandBuilder
	dockerArgs.add(fmt.Sprintf("ldcircleci/sse-contract-tests:%s", c.outputDockerScriptVersion))
	dockerArgs.add("--url", c.serviceURL)
	dockerArgs.add("--host", "testharness")
	for _, r := range c.filters.MustMatch {
		dockerArgs.add("--run", r.String())
	}
	for _, r := range c.filters.MustNotMatch {
		dockerArgs.add("--skip", r.String())
	}
	if c.debug {
		dockerArgs.add("--debug")
	}
	if c.debugAll {
		dockerArgs.add("--debug-all")
	}

	cleanupCommand := fmt.Sprintf("docker stop %s >/dev/null 2>&1; docker network rm contract-tests-network >/dev/null 2>&1",
		testServiceHostname)

	fmt.Println("# This script was generated by running sse-contract-tests with the --output-docker-script option")
	fmt.Println("# It assumes that you have already build the test service as a Docker image with the same name")
	fmt.Println("# as the hostname of the target URL")
	fmt.Println("echo; echo 'Starting contract test service...'")
	fmt.Println("docker network create contract-tests-network >/dev/null 2>&1 || true")
	fmt.Printf("docker run --rm -d -p %s:%s --network contract-tests-network --name %s %s\n",
		testServicePort, testServicePort, testServiceHostname, testServiceHostname)
	fmt.Println("echo; echo 'Running test harness'")
	fmt.Printf("docker run --rm -p %d:%d -t --network contract-tests-network --name testharness \\\n"+
		"%s --host testharness \\\n"+
		"|| (echo; echo 'Output from test service follows:'; docker logs testservice; \\\n"+
		"    %s; exit 1)\n",
		defaultPort, defaultPort, dockerArgs, cleanupCommand)
	fmt.Println(cleanupCommand)
}

type commandBuilder []string

func (b *commandBuilder) add(args ...string) {
	for _, a := range args {
		*b = append(*b, shellescape.Quote(a))
	}
}

func (b commandBuilder) String() string {
	return strings.Join(b, " ")
}
